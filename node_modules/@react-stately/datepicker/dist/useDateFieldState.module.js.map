{"mappings":";;;;;;;;;AAAA;;;;;;;;;;CAUC;;;;;;;;AAkGD,MAAM,0CAAoB;IACxB,MAAM;IACN,OAAO;IACP,KAAK;IACL,MAAM;IACN,QAAQ;IACR,QAAQ;IACR,WAAW;IACX,KAAK;AACP;AAEA,MAAM,kCAAY;IAChB,MAAM;IACN,OAAO;IACP,KAAK;IACL,MAAM;IACN,QAAQ;IACR,QAAQ;AACV;AAEA,MAAM,qCAAe;IACnB,mDAAmD;IACnD,WAAW;IACX,iIAAiI;IACjI,aAAa;IACb,UAAU;IACV,SAAS;AACX;AAwBO,SAAS,0CAAmD,KAA+B;IAChG,IAAI,UACF,MAAM,kBACN,cAAc,gBACd,YAAY,cACZ,aAAa,mBACb,aAAa,mBACb,aAAa,iBACb,QAAQ,YACR,QAAQ,qBACR,iBAAiB,EAClB,GAAG;IAEJ,IAAI,IAAsB,MAAM,KAAK,IAAI,MAAM,YAAY,IAAI,MAAM,gBAAgB,IAAI;IACzF,IAAI,CAAC,aAAa,gBAAgB,GAAG,CAAA,GAAA,yCAAc,EAAE,GAAG,MAAM,WAAW;IACzE,IAAI,WAAW,mBAAmB;IAElC,yEAAyE;IACzE,IAAI,KAAK,CAAE,CAAA,eAAe,CAAA,GACxB,MAAM,IAAI,MAAM,yBAAyB,cAAc,gBAAgB,EAAE,QAAQ;IAGnF,kDAAkD;IAClD,IAAI,CAAC,UAAU,UAAU,GAAG,CAAA,GAAA,cAAM,EAAE;QAClC,IAAI,YAAY,IAAI,CAAA,GAAA,oBAAY,EAAE,QAAQ;YACxC,WAAW;YACX,WAAW;YACX,QAAQ,MAAM,SAAS,IAAI,OAAO,MAAM,SAAS,KAAK,KAAK;QAC7D;QACA,IAAI,OAAO,UAAU,eAAe;QACpC,IAAI,WAAW,eAAe,KAAK,QAAQ;QAC3C,OAAO;YAAC;YAAU,KAAK,SAAS;SAAE;IACpC,GAAG;QAAC;QAAQ,MAAM,SAAS;QAAE;KAAe;QAI1C;IAFF,IAAI,CAAC,OAAO,QAAQ,GAAG,CAAA,GAAA,yBAAiB,EACtC,MAAM,KAAK,EACX,CAAA,sBAAA,MAAM,YAAY,cAAlB,iCAAA,sBAAsB,MACtB,MAAM,QAAQ;IAGhB,IAAI,CAAC,aAAa,GAAG,CAAA,GAAA,eAAO,EAAE;IAC9B,IAAI,gBAAgB,CAAA,GAAA,cAAM,EAAE;YAAM;eAAA,CAAA,gBAAA,CAAA,GAAA,yCAAW,EAAE,OAAO,uBAApB,2BAAA,gBAAiC;OAAM;QAAC;QAAO;KAAS;IAC1F,IAAI,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,eAAO,EAC3C,IAAM,IAAI,CAAA,GAAA,yCAAa,EAAE,UAAU,WAAW;IAGhD,IAAI,UAAU,SAAS,UAAU,KAAK,aAAa,aAAa,GAAG,KAAK;IACxE,IAAI,aAAa,CAAA,GAAA,cAAM,EAAE;YAEP;eAFc;yBAC9B;YACA,gBAAgB,CAAA,wBAAA,MAAM,cAAc,cAApB,mCAAA,wBAAwB;YACxC,UAAU;0BACV;YACA,WAAW,MAAM,SAAS;qBAC1B;YACA,yBAAyB,MAAM,uBAAuB;QACxD;OAAI;QAAC,MAAM,cAAc;QAAE;QAAa,MAAM,SAAS;QAAE,MAAM,uBAAuB;QAAE;QAAiB;QAAc;KAAQ;IAC/H,IAAI,OAAO,CAAA,GAAA,cAAM,EAAE,IAAM,CAAA,GAAA,yCAAe,EAAE,CAAC,GAAG,aAAa;QAAC;KAAW;IAEvE,IAAI,gBAAgB,CAAA,GAAA,cAAM,EAAE,IAAM,IAAI,CAAA,GAAA,oBAAY,EAAE,QAAQ,OAAO;QAAC;QAAQ;KAAK;IACjF,IAAI,kBAAkB,CAAA,GAAA,cAAM,EAAE,IAAM,cAAc,eAAe,IAAI;QAAC;KAAc;IACpF,IAAI,cAAc,CAAA,GAAA,cAAM,EAAE,IAAM,CAAA,GAAA,yCAAoB,EAAE,MAAM,gBAAgB,EAAE,aAAa,UAAU,kBAAkB;QAAC,MAAM,gBAAgB;QAAE;QAAa;QAAU;KAAgB;IACvL,IAAI,kBAAkB,CAAA,GAAA,cAAM,EAAE;QAC5B,IAAI,gBAAgB,cAAc,SAAS,cAAc;QACzD,IAAI,WAA0B;YAAC;YAAO;YAAQ;YAAS;YAAO;eAAY,gBAAgB;gBAAC;aAAqB,GAAG,EAAE;YAAG;YAAU;SAAS;QAC3I,IAAI,WAAW,SAAS,OAAO,CAAC,MAAM,cAAc,IAAI;QACxD,IAAI,WAAW,SAAS,OAAO,CAAC,gBAAgB,UAAU,gBAAgB,cAAc;QACxF,OAAO,SAAS,KAAK,CAAC,UAAU,WAAW;IAC7C,GAAG;QAAC,MAAM,cAAc;QAAE;QAAa;KAAU;IAEjD,IAAI,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,eAAO,EAAE;IACzC,IAAI,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,eAAO,EAAE;IAC/C,IAAI,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,eAAO,EAAE;IACjD,IAAI,kBAAkB,aAAa,cAAc,iBAAiB,CAAC,CAAA,GAAA,sBAAc,EAAE,UAAU,eAAe;QAC1G,eAAe,IAAI,CAAA,GAAA,yCAAa,EAAE,UAAU,WAAW;QACvD,aAAa;QACb,gBAAgB;QAChB,iBAAiB;QACjB,gBAAgB;IAClB;IAEA,IAAI,WAAW,CAAC;QACd,IAAI,MAAM,UAAU,IAAI,MAAM,UAAU,EACtC;QAGF,IAAI,YAAY,QAAS,oBAAoB,CAAA,GAAA,yCAAa,KAAK,SAAS,SAAS,CAAC,kBAAmB;YACnG,gBAAgB,IAAI,CAAA,GAAA,yCAAa,EAAE,UAAU,WAAW;YACxD,QAAQ;QACV,OAAO,IAAI,CAAE,CAAA,oBAAoB,CAAA,GAAA,yCAAa,CAAA,GAAI;YAChD,wEAAwE;YACxE,sFAAsF;YACtF,WAAW,CAAA,GAAA,iBAAS,EAAE,UAAU,CAAA,cAAA,wBAAA,EAAG,QAAQ,KAAI,IAAI,CAAA,GAAA,wBAAgB;YACnE,gBAAgB,IAAI,CAAA,GAAA,yCAAa,EAAE,UAAU,WAAW;YACxD,QAAQ;QACV,OAAO;YACL,oEAAoE;YACpE,wEAAwE;YACxE,uDAAuD;YACvD,IAAI,SAAS,UAAU,CAAC,kBAAkB;gBACxC,IAAI,YAAY,SAAS,OAAO,CAAC,0BAAA,2BAAA,gBAAiB;gBAClD,IAAI,SAAS,QAAQ,CAAC,WAAW,kBAAkB;oBACjD,IAAI,eAAe,CAAA,GAAA,iBAAS,EAAE,WAAW,CAAA,cAAA,wBAAA,EAAG,QAAQ,KAAI,IAAI,CAAA,GAAA,wBAAgB;oBAC5E,IAAI,CAAC,SAAS,aAAa,OAAO,CAAC,WAAW,GAAG;wBAC/C,gBAAgB,IAAI,CAAA,GAAA,yCAAa,EAAE,UAAU,WAAW,iBAAiB,mCAAmC;wBAC5G,QAAQ;wBACR;oBACF;gBACF;YACF;YAEA,4DAA4D;YAC5D,gBAAgB;QAClB;IACF;IAEA,IAAI,YAAY,CAAA,GAAA,cAAM,EAAE;QACtB,IAAI,IAAI,aAAa,OAAO,CAAC,0BAAA,2BAAA,gBAAiB;QAC9C,OAAO,EAAE,MAAM,CAAC;IAClB,GAAG;QAAC;QAAc;QAAU;QAAe;KAAY;IAEvD,IAAI,WAAW,CAAA,GAAA,cAAM,EACnB,IAAM,sCAAgB,WAAW,cAAc,eAAe,iBAAiB,UAAU,QAAQ,cACjG;QAAC;QAAW;QAAe;QAAiB;QAAc;QAAU;QAAQ;KAAY;IAG1F,IAAI,gBAAgB,CAAC,MAAmB;QACtC,SAAS,aAAa,KAAK,CAAC,MAAM,QAAQ,aAAa;IACzD;IAEA,IAAI,oBAAoB,CAAA,GAAA,cAAM,EAAE,IAAM,CAAA,GAAA,yCAAkB,EACtD,OACA,UACA,UACA,mBACA,aACC;QAAC;QAAO;QAAU;QAAU;QAAmB;KAAW;IAE7D,IAAI,aAAa,CAAA,GAAA,6BAAqB,EAAE;QACtC,GAAG,KAAK;QACR,OAAO;2BACP;IACF;IAEA,IAAI,iBAAiB,WAAW,iBAAiB,CAAC,SAAS;IAC3D,IAAI,kBAA0C,MAAM,eAAe,IAAK,CAAA,iBAAiB,YAAY,IAAG;QAKxF,sBASE;IAZlB,OAAO;QACL,GAAG,UAAU;QACb,OAAO;QACP,cAAc,CAAA,uBAAA,MAAM,YAAY,cAAlB,kCAAA,uBAAsB;mBACpC;kBACA;kBACA;kBACA;uBACA;yBACA;QACA,WAAW;qBACX;QACA,gBAAgB,CAAA,wBAAA,MAAM,cAAc,cAApB,mCAAA,wBAAwB;oBACxC;oBACA;oBACA;QACA,WAAU,IAAI;YACZ,cAAc,MAAM;QACtB;QACA,WAAU,IAAI;YACZ,cAAc,MAAM;QACtB;QACA,eAAc,IAAI;YAChB,cAAc,MAAM,+BAAS,CAAC,KAAK,IAAI;QACzC;QACA,eAAc,IAAI;YAChB,cAAc,MAAM,CAAE,CAAA,+BAAS,CAAC,KAAK,IAAI,CAAA;QAC3C;QACA,gBAAe,IAAI;YACjB,IAAI,WAAW,SAAS,UAAU,cAAc,QAC5C,KACA,aAAa,gBAAgB,CAAC,MAAO,QAAQ;YACjD,SAAS,aAAa,GAAG,CAAC,MAAM,UAAU;QAC5C;QACA,gBAAe,IAAI;YACjB,IAAI,WAAW,SAAS,UAAU,cAAc,QAC5C,KACA,aAAa,gBAAgB,CAAC,MAAO,QAAQ;YACjD,SAAS,aAAa,GAAG,CAAC,MAAM,UAAU;QAC5C;QACA,YAAW,IAAI,EAAE,CAAkB;YACjC,SAAS,aAAa,GAAG,CAAC,MAAM,GAAG;QACrC;QACA;YACE,IAAI,MAAM,UAAU,IAAI,MAAM,UAAU,EACtC;YAGF,mGAAmG;YACnG,IAAI,aAAa,UAAU,CAAC,kBAAkB;gBAC5C,IAAI,YAAY,aAAa,OAAO,CAAC,0BAAA,2BAAA,gBAAiB;gBACtD,IAAI,eAAe,CAAA,GAAA,iBAAS,EAAE,WAAW,CAAA,cAAA,wBAAA,EAAG,QAAQ,KAAI,IAAI,CAAA,GAAA,wBAAgB;gBAC5E,IAAI,CAAC,SAAS,aAAa,OAAO,CAAC,WAAW,GAC5C,QAAQ;gBAEV,gBAAgB,IAAI,CAAA,GAAA,yCAAa,EAAE,UAAU,WAAW;YAC1D;QACF;QACA,cAAa,IAAI;YACf,IAAI,QAAQ;YAEZ,IAAI,SAAS,kBAAkB,SAAS,WACtC,QAAQ,aAAa,KAAK,CAAC;YAG7B,SAAS;QACX;QACA,aAAY,YAA0B;YACpC,IAAI,CAAC,eACH,OAAO;YAGT,IAAI,gBAAgB,CAAA,GAAA,yCAAe,EAAE,cAAc;YACnD,IAAI,YAAY,IAAI,CAAA,GAAA,oBAAY,EAAE,QAAQ;YAC1C,OAAO,UAAU,MAAM,CAAC;QAC1B;QACA,kBAAiB,MAAM,EAAE,aAA+B;YACtD,IAAI,aAAa;gBAAC,GAAG,UAAU;gBAAE,GAAG,aAAa;YAAA;YACjD,IAAI,mBAAmB,CAAA,GAAA,yCAAe,EAAE,CAAC,GAAG;YAC5C,OAAO,IAAI,CAAA,GAAA,oBAAY,EAAE,QAAQ;QACnC;IACF;AACF;AAEA,SAAS,sCACP,SAAe,EACf,YAA4B,EAC5B,aAAkC,EAClC,eAAmD,EACnD,QAAkB,EAClB,MAAc,EACd,WAAwB;IAExB,IAAI,YAAY;QAAC;QAAQ;QAAU;KAAS;IAC5C,IAAI,WAAW,cAAc,aAAa,CAAC;IAE3C,8FAA8F;IAC9F,+EAA+E;IAC/E,gFAAgF;IAChF,IAAI,kBAAkB,IAAI,CAAA,GAAA,sBAAc,EAAE,QAAQ;QAAC,aAAa;IAAK;IACrE,IAAI,oBAAoB,IAAI,CAAA,GAAA,sBAAc,EAAE,QAAQ;QAAC,aAAa;QAAO,sBAAsB;IAAC;IAChG,KAAK,IAAI,WAAW,SAClB,IAAI,QAAQ,IAAI,KAAK,UAAU,QAAQ,IAAI,KAAK,WAAW,QAAQ,IAAI,KAAK,SAAS,QAAQ,IAAI,KAAK,QAAQ;YAChG;QAAZ,IAAI,QAAQ,CAAA,6BAAA,YAAY,CAAC,QAAQ,IAAI,CAAC,cAA1B,wCAAA,6BAA8B;QAC1C,IAAI,eAAe,CAAC,QAAQ,IAAI,CAAC,KAAK,WACpC,QAAQ,KAAK,GAAG,kBAAkB,MAAM,CAAC;aAEzC,QAAQ,KAAK,GAAG,gBAAgB,MAAM,CAAC;IAE3C;IAGF,IAAI,oBAAmC,EAAE;IACzC,KAAK,IAAI,WAAW,SAAU;QAC5B,IAAI,OAAO,kCAAY,CAAC,QAAQ,IAAI,CAAC,IAAI,QAAQ,IAAI;QACrD,IAAI,aAAa,uCAAiB,CAAC,KAAK;QACxC,IAAI,SAAS,SAAS,SAAS,OAAO,GAAG,MAAM,KAAK,GAClD,aAAa;QAGf,IAAI,gBAAgB,uCAAiB,CAAC,KAAK,IAAI,YAAY,CAAC,QAAQ,IAAI,CAAC,IAAI;QAC7E,IAAI,cAAc,uCAAiB,CAAC,KAAK,GAAG,CAAA,GAAA,yCAAa,EAAE,MAAM,QAAQ,KAAK,EAAE,UAAU;QAE1F,IAAI,cAAc;kBAChB;YACA,MAAM,gBAAgB,cAAc,QAAQ,KAAK;YACjD,GAAG,aAAa,gBAAgB,CAAC,KAAK;2BACtC;yBACA;wBACA;QACF;QAEA,sGAAsG;QACtG,gMAAgM;QAChM,0JAA0J;QAC1J,IAAI,SAAS,QAAQ;YACnB,yDAAyD;YACzD,kBAAkB,IAAI,CAAC;gBACrB,MAAM;gBACN,MAAM;gBACN,eAAe;gBACf,aAAa;gBACb,YAAY;YACd;YACA,kBAAkB,IAAI,CAAC;YACvB,yGAAyG;YACzG,IAAI,SAAS,aACX,kBAAkB,IAAI,CAAC;gBACrB,MAAM;gBACN,MAAM;gBACN,eAAe;gBACf,aAAa;gBACb,YAAY;YACd;QAEJ,OAAO,IAAI,UAAU,QAAQ,CAAC,SAAS,SAAS,aAAa;YAC3D,kBAAkB,IAAI,CAAC;YACvB,uDAAuD;YACvD,kBAAkB,IAAI,CAAC;gBACrB,MAAM;gBACN,MAAM;gBACN,eAAe;gBACf,aAAa;gBACb,YAAY;YACd;QACF,OACE,+HAA+H;QAC/H,kBAAkB,IAAI,CAAC;IAE3B;IAEA,OAAO;AACT","sources":["packages/@react-stately/datepicker/src/useDateFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Calendar, CalendarIdentifier, DateFormatter, GregorianCalendar, isEqualCalendar, toCalendar} from '@internationalized/date';\nimport {convertValue, createPlaceholderDate, FieldOptions, FormatterOptions, getFormatOptions, getValidationResult, useDefaultProps} from './utils';\nimport {DatePickerProps, DateValue, Granularity, MappedDateValue} from '@react-types/datepicker';\nimport {FormValidationState, useFormValidationState} from '@react-stately/form';\nimport {getPlaceholder} from './placeholders';\nimport {IncompleteDate} from './IncompleteDate';\nimport {NumberFormatter} from '@internationalized/number';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useState} from 'react';\nimport {ValidationState} from '@react-types/shared';\n\nexport type SegmentType = 'era' | 'year' | 'month' | 'day' |  'hour' | 'minute' | 'second' | 'dayPeriod' | 'literal' | 'timeZoneName';\nexport interface DateSegment {\n  /** The type of segment. */\n  type: SegmentType,\n  /** The formatted text for the segment. */\n  text: string,\n  /** The numeric value for the segment, if applicable. */\n  value?: number | null,\n  /** The minimum numeric value for the segment, if applicable. */\n  minValue?: number,\n  /** The maximum numeric value for the segment, if applicable. */\n  maxValue?: number,\n  /** Whether the value is a placeholder. */\n  isPlaceholder: boolean,\n  /** A placeholder string for the segment. */\n  placeholder: string,\n  /** Whether the segment is editable. */\n  isEditable: boolean\n}\n\nexport interface DateFieldState extends FormValidationState {\n  /** The current field value. */\n  value: DateValue | null,\n  /** The default field value. */\n  defaultValue: DateValue | null,\n  /** The current value, converted to a native JavaScript `Date` object.  */\n  dateValue: Date,\n  /** The calendar system currently in use. */\n  calendar: Calendar,\n  /** Sets the field's value. */\n  setValue(value: DateValue | null): void,\n  /** A list of segments for the current value. */\n  segments: DateSegment[],\n  /** A date formatter configured for the current locale and format. */\n  dateFormatter: DateFormatter,\n  /**\n   * The current validation state of the date field, based on the `validationState`, `minValue`, and `maxValue` props.\n   * @deprecated Use `isInvalid` instead.\n   */\n  validationState: ValidationState | null,\n  /** Whether the date field is invalid, based on the `isInvalid`, `minValue`, and `maxValue` props. */\n  isInvalid: boolean,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** The maximum date or time unit that is displayed in the field. */\n  maxGranularity: 'year' | 'month' | Granularity,\n  /** Whether the field is disabled. */\n  isDisabled: boolean,\n  /** Whether the field is read only. */\n  isReadOnly: boolean,\n  /** Whether the field is required. */\n  isRequired: boolean,\n  /** Increments the given segment. Upon reaching the minimum or maximum value, the value wraps around to the opposite limit. */\n  increment(type: SegmentType): void,\n  /** Decrements the given segment. Upon reaching the minimum or maximum value, the value wraps around to the opposite limit. */\n  decrement(type: SegmentType): void,\n  /**\n   * Increments the given segment by a larger amount, rounding it to the nearest increment.\n   * The amount to increment by depends on the field, for example 15 minutes, 7 days, and 5 years.\n   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.\n   */\n  incrementPage(type: SegmentType): void,\n  /**\n   * Decrements the given segment by a larger amount, rounding it to the nearest increment.\n   * The amount to decrement by depends on the field, for example 15 minutes, 7 days, and 5 years.\n   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.\n   */\n  decrementPage(type: SegmentType): void,\n  /** Increments the given segment to its maxiumum value. */\n  incrementToMax(type: SegmentType): void,\n  /** Decrements the given segment to its minimum value. */\n  decrementToMin(type: SegmentType): void,\n  /** Sets the value of the given segment. */\n  setSegment(type: 'era', value: string): void,\n  setSegment(type: SegmentType, value: number): void,\n  /** Updates the remaining unfilled segments with the placeholder value. */\n  confirmPlaceholder(): void,\n  /** Clears the value of the given segment, reverting it to the placeholder. */\n  clearSegment(type: SegmentType): void,\n  /** Formats the current date value using the given options. */\n  formatValue(fieldOptions: FieldOptions): string,\n  /** Gets a formatter based on state's props. */\n  getDateFormatter(locale: string, formatOptions: FormatterOptions): DateFormatter\n}\n\nconst EDITABLE_SEGMENTS = {\n  year: true,\n  month: true,\n  day: true,\n  hour: true,\n  minute: true,\n  second: true,\n  dayPeriod: true,\n  era: true\n};\n\nconst PAGE_STEP = {\n  year: 5,\n  month: 2,\n  day: 7,\n  hour: 2,\n  minute: 15,\n  second: 15\n};\n\nconst TYPE_MAPPING = {\n  // Node seems to convert everything to lowercase...\n  dayperiod: 'dayPeriod',\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/formatToParts#named_years\n  relatedYear: 'year',\n  yearName: 'literal', // not editable\n  unknown: 'literal'\n};\n\nexport interface DateFieldStateOptions<T extends DateValue = DateValue> extends DatePickerProps<T> {\n  /**\n   * The maximum unit to display in the date field.\n   * @default 'year'\n   */\n  maxGranularity?: 'year' | 'month' | Granularity,\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: CalendarIdentifier) => Calendar\n}\n\n/**\n * Provides state management for a date field component.\n * A date field allows users to enter and edit date and time values using a keyboard.\n * Each part of a date value is displayed in an individually editable segment.\n */\nexport function useDateFieldState<T extends DateValue = DateValue>(props: DateFieldStateOptions<T>): DateFieldState {\n  let {\n    locale,\n    createCalendar,\n    hideTimeZone,\n    isDisabled = false,\n    isReadOnly = false,\n    isRequired = false,\n    minValue,\n    maxValue,\n    isDateUnavailable\n  } = props;\n\n  let v: DateValue | null = props.value || props.defaultValue || props.placeholderValue || null;\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let timeZone = defaultTimeZone || 'UTC';\n\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && !(granularity in v)) {\n    throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  }\n\n  // Resolve default hour cycle and calendar system.\n  let [calendar, hourCycle] = useMemo(() => {\n    let formatter = new DateFormatter(locale, {\n      dateStyle: 'short',\n      timeStyle: 'short',\n      hour12: props.hourCycle != null ? props.hourCycle === 12 : undefined\n    });\n    let opts = formatter.resolvedOptions();\n    let calendar = createCalendar(opts.calendar as CalendarIdentifier);\n    return [calendar, opts.hourCycle!];\n  }, [locale, props.hourCycle, createCalendar]);\n\n  let [value, setDate] = useControlledState<DateValue | null, MappedDateValue<T> | null>(\n    props.value,\n    props.defaultValue ?? null,\n    props.onChange\n  );\n\n  let [initialValue] = useState(value);\n  let calendarValue = useMemo(() => convertValue(value, calendar) ?? null, [value, calendar]);\n  let [displayValue, setDisplayValue] = useState(\n    () => new IncompleteDate(calendar, hourCycle, calendarValue)\n  );\n\n  let showEra = calendar.identifier === 'gregory' && displayValue.era === 'BC';\n  let formatOpts = useMemo(() => ({\n    granularity,\n    maxGranularity: props.maxGranularity ?? 'year',\n    timeZone: defaultTimeZone,\n    hideTimeZone,\n    hourCycle: props.hourCycle,\n    showEra,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros\n  }), [props.maxGranularity, granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, hideTimeZone, showEra]);\n  let opts = useMemo(() => getFormatOptions({}, formatOpts), [formatOpts]);\n\n  let dateFormatter = useMemo(() => new DateFormatter(locale, opts), [locale, opts]);\n  let resolvedOptions = useMemo(() => dateFormatter.resolvedOptions(), [dateFormatter]);\n  let placeholder = useMemo(() => createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone), [props.placeholderValue, granularity, calendar, defaultTimeZone]);\n  let displaySegments = useMemo(() => {\n    let is12HourClock = hourCycle === 'h11' || hourCycle === 'h12';\n    let segments: SegmentType[] = ['era', 'year', 'month', 'day', 'hour', ...(is12HourClock ? ['dayPeriod' as const] : []), 'minute', 'second'];\n    let minIndex = segments.indexOf(props.maxGranularity || 'era');\n    let maxIndex = segments.indexOf(granularity === 'hour' && is12HourClock ? 'dayPeriod' : granularity);\n    return segments.slice(minIndex, maxIndex + 1);\n  }, [props.maxGranularity, granularity, hourCycle]);\n\n  let [lastValue, setLastValue] = useState(calendarValue);\n  let [lastCalendar, setLastCalendar] = useState(calendar);\n  let [lastHourCycle, setLastHourCycle] = useState(hourCycle);\n  if (calendarValue !== lastValue || hourCycle !== lastHourCycle || !isEqualCalendar(calendar, lastCalendar)) {\n    displayValue = new IncompleteDate(calendar, hourCycle, calendarValue);\n    setLastValue(calendarValue);\n    setLastCalendar(calendar);\n    setLastHourCycle(hourCycle);\n    setDisplayValue(displayValue);\n  }\n\n  let setValue = (newValue: DateValue | IncompleteDate | null) => {\n    if (props.isDisabled || props.isReadOnly) {\n      return;\n    }\n\n    if (newValue == null || (newValue instanceof IncompleteDate && newValue.isCleared(displaySegments))) {\n      setDisplayValue(new IncompleteDate(calendar, hourCycle, calendarValue));\n      setDate(null);\n    } else if (!(newValue instanceof IncompleteDate)) {\n      // The display calendar should not have any effect on the emitted value.\n      // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n      newValue = toCalendar(newValue, v?.calendar || new GregorianCalendar());\n      setDisplayValue(new IncompleteDate(calendar, hourCycle, calendarValue));\n      setDate(newValue);\n    } else {\n      // If the new value is complete and valid, trigger onChange eagerly.\n      // If it represents an incomplete or invalid value (e.g. February 30th),\n      // wait until the field is blurred to trigger onChange.\n      if (newValue.isComplete(displaySegments)) {\n        let dateValue = newValue.toValue(calendarValue ?? placeholder);\n        if (newValue.validate(dateValue, displaySegments)) {\n          let newDateValue = toCalendar(dateValue, v?.calendar || new GregorianCalendar());\n          if (!value || newDateValue.compare(value) !== 0) {\n            setDisplayValue(new IncompleteDate(calendar, hourCycle, calendarValue)); // reset in case prop isn't updated\n            setDate(newDateValue);\n            return;\n          }\n        }\n      }\n\n      // Incomplete/invalid value. Set temporary display override.\n      setDisplayValue(newValue);\n    }\n  };\n\n  let dateValue = useMemo(() => {\n    let v = displayValue.toValue(calendarValue ?? placeholder);\n    return v.toDate(timeZone);\n  }, [displayValue, timeZone, calendarValue, placeholder]);\n\n  let segments = useMemo(\n    () => processSegments(dateValue, displayValue, dateFormatter, resolvedOptions, calendar, locale, granularity),\n    [dateValue, dateFormatter, resolvedOptions, displayValue, calendar, locale, granularity]\n  );\n\n  let adjustSegment = (type: SegmentType, amount: number) => {\n    setValue(displayValue.cycle(type, amount, placeholder, displaySegments));\n  };\n\n  let builtinValidation = useMemo(() => getValidationResult(\n    value,\n    minValue,\n    maxValue,\n    isDateUnavailable,\n    formatOpts\n  ), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n\n  let validation = useFormValidationState({\n    ...props,\n    value: value as MappedDateValue<T> | null,\n    builtinValidation\n  });\n\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState: ValidationState | null = props.validationState || (isValueInvalid ? 'invalid' : null);\n\n  return {\n    ...validation,\n    value: calendarValue,\n    defaultValue: props.defaultValue ?? initialValue,\n    dateValue,\n    calendar,\n    setValue,\n    segments,\n    dateFormatter,\n    validationState,\n    isInvalid: isValueInvalid,\n    granularity,\n    maxGranularity: props.maxGranularity ?? 'year',\n    isDisabled,\n    isReadOnly,\n    isRequired,\n    increment(part) {\n      adjustSegment(part, 1);\n    },\n    decrement(part) {\n      adjustSegment(part, -1);\n    },\n    incrementPage(part) {\n      adjustSegment(part, PAGE_STEP[part] || 1);\n    },\n    decrementPage(part) {\n      adjustSegment(part, -(PAGE_STEP[part] || 1));\n    },\n    incrementToMax(part) {\n      let maxValue = part === 'hour' && hourCycle === 'h12'\n        ? 11\n        : displayValue.getSegmentLimits(part)!.maxValue;\n      setValue(displayValue.set(part, maxValue, placeholder));\n    },\n    decrementToMin(part) {\n      let minValue = part === 'hour' && hourCycle === 'h12'\n        ? 12\n        : displayValue.getSegmentLimits(part)!.minValue;\n      setValue(displayValue.set(part, minValue, placeholder));\n    },\n    setSegment(part, v: string | number) {\n      setValue(displayValue.set(part, v, placeholder));\n    },\n    confirmPlaceholder() {\n      if (props.isDisabled || props.isReadOnly) {\n        return;\n      }\n\n      // If the display value is complete but invalid, we need to constrain it and emit onChange on blur.\n      if (displayValue.isComplete(displaySegments)) {\n        let dateValue = displayValue.toValue(calendarValue ?? placeholder);\n        let newDateValue = toCalendar(dateValue, v?.calendar || new GregorianCalendar());\n        if (!value || newDateValue.compare(value) !== 0) {\n          setDate(newDateValue);\n        }\n        setDisplayValue(new IncompleteDate(calendar, hourCycle, calendarValue));\n      }\n    },\n    clearSegment(part) {\n      let value = displayValue;\n\n      if (part !== 'timeZoneName' && part !== 'literal') {\n        value = displayValue.clear(part);\n      }\n\n      setValue(value);\n    },\n    formatValue(fieldOptions: FieldOptions) {\n      if (!calendarValue) {\n        return '';\n      }\n\n      let formatOptions = getFormatOptions(fieldOptions, formatOpts);\n      let formatter = new DateFormatter(locale, formatOptions);\n      return formatter.format(dateValue);\n    },\n    getDateFormatter(locale, formatOptions: FormatterOptions) {\n      let newOptions = {...formatOpts, ...formatOptions};\n      let newFormatOptions = getFormatOptions({}, newOptions);\n      return new DateFormatter(locale, newFormatOptions);\n    }\n  };\n}\n\nfunction processSegments(\n  dateValue: Date,\n  displayValue: IncompleteDate,\n  dateFormatter: Intl.DateTimeFormat,\n  resolvedOptions: Intl.ResolvedDateTimeFormatOptions,\n  calendar: Calendar,\n  locale: string,\n  granularity: Granularity\n) : DateSegment[] {\n  let timeValue = ['hour', 'minute', 'second'];\n  let segments = dateFormatter.formatToParts(dateValue);\n\n  // In order to allow formatting temporarily invalid dates during editing (e.g. February 30th),\n  // use a NumberFormatter to manually format segments directly from raw numbers.\n  // When the user blurs the date field, the invalid segments will be constrained.\n  let numberFormatter = new NumberFormatter(locale, {useGrouping: false});\n  let twoDigitFormatter = new NumberFormatter(locale, {useGrouping: false, minimumIntegerDigits: 2});\n  for (let segment of segments) {\n    if (segment.type === 'year' || segment.type === 'month' || segment.type === 'day' || segment.type === 'hour') {\n      let value = displayValue[segment.type] ?? 0;\n      if (resolvedOptions[segment.type] === '2-digit') {\n        segment.value = twoDigitFormatter.format(value);\n      } else {\n        segment.value = numberFormatter.format(value);\n      }\n    }\n  }\n\n  let processedSegments: DateSegment[] = [];\n  for (let segment of segments) {\n    let type = TYPE_MAPPING[segment.type] || segment.type;\n    let isEditable = EDITABLE_SEGMENTS[type];\n    if (type === 'era' && calendar.getEras().length === 1) {\n      isEditable = false;\n    }\n\n    let isPlaceholder = EDITABLE_SEGMENTS[type] && displayValue[segment.type] == null;\n    let placeholder = EDITABLE_SEGMENTS[type] ? getPlaceholder(type, segment.value, locale) : null;\n\n    let dateSegment = {\n      type,\n      text: isPlaceholder ? placeholder : segment.value,\n      ...displayValue.getSegmentLimits(type),\n      isPlaceholder,\n      placeholder,\n      isEditable\n    } as DateSegment;\n\n    // There is an issue in RTL languages where time fields render (minute:hour) instead of (hour:minute).\n    // To force an LTR direction on the time field since, we wrap the time segments in LRI (left-to-right) isolate unicode. See https://www.w3.org/International/questions/qa-bidi-unicode-controls.\n    // These unicode characters will be added to the array of processed segments as literals and will mark the start and end of the embedded direction change.\n    if (type === 'hour') {\n      // This marks the start of the embedded direction change.\n      processedSegments.push({\n        type: 'literal',\n        text: '\\u2066',\n        isPlaceholder: false,\n        placeholder: '',\n        isEditable: false\n      });\n      processedSegments.push(dateSegment);\n      // This marks the end of the embedded direction change in the case that the granularity it set to \"hour\".\n      if (type === granularity) {\n        processedSegments.push({\n          type: 'literal',\n          text: '\\u2069',\n          isPlaceholder: false,\n          placeholder: '',\n          isEditable: false\n        });\n      }\n    } else if (timeValue.includes(type) && type === granularity) {\n      processedSegments.push(dateSegment);\n      // This marks the end of the embedded direction change.\n      processedSegments.push({\n        type: 'literal',\n        text: '\\u2069',\n        isPlaceholder: false,\n        placeholder: '',\n        isEditable: false\n      });\n    } else {\n      // We only want to \"wrap\" the unicode around segments that are hour, minute, or second. If they aren't, just process as normal.\n      processedSegments.push(dateSegment);\n    }\n  }\n\n  return processedSegments;\n}\n"],"names":[],"version":3,"file":"useDateFieldState.module.js.map"}