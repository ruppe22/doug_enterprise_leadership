{"mappings":"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","sources":["packages/@react-stately/datepicker/src/IncompleteDate.ts"],"sourcesContent":["/*\n * Copyright 2026 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AnyDateTime, Calendar, CalendarDate, ZonedDateTime} from '@internationalized/date';\nimport {DateValue} from '@react-types/datepicker';\nimport {SegmentType} from './useDateFieldState';\n\ntype HourCycle = 'h12' | 'h11' | 'h23' | 'h24';\n\n/**\n * This class represents a date that is incomplete or otherwise invalid as a result of user editing.\n * For example, it can represent temporary dates such as February 31st if the user edits the day before the month.\n * Times are represented according to an hour cycle rather than always in 24 hour time. This enables the user to adjust\n * the day period (e.g. am/pm) independently from the hour.\n */\nexport class IncompleteDate {\n  calendar: Calendar;\n  era: string | null;\n  year: number | null;\n  month: number | null;\n  day: number | null;\n  hour: number | null;\n  hourCycle: HourCycle;\n  dayPeriod: number | null;\n  minute: number | null;\n  second: number | null;\n  millisecond: number | null;\n  offset: number | null;\n\n  constructor(calendar: Calendar, hourCycle: HourCycle, dateValue?: Partial<Omit<AnyDateTime, 'copy'>> | null) {\n    this.era = dateValue?.era ?? null;\n    this.calendar = calendar;\n    this.year = dateValue?.year ?? null;\n    this.month = dateValue?.month ?? null;\n    this.day = dateValue?.day ?? null;\n    this.hour = dateValue?.hour ?? null;\n    this.hourCycle = hourCycle;\n    this.dayPeriod = null;\n    this.minute = dateValue?.minute ?? null;\n    this.second = dateValue?.second ?? null;\n    this.millisecond = dateValue?.millisecond ?? null;\n    this.offset = 'offset' in (dateValue ?? {}) ? (dateValue as any).offset : null;\n\n    // Convert the hour from 24 hour time to the given hour cycle.\n    if (this.hour != null) {\n      let [dayPeriod, hour] = toHourCycle(this.hour, hourCycle);\n      this.dayPeriod = dayPeriod;\n      this.hour = hour;\n    }\n  }\n\n  copy(): IncompleteDate {\n    let res = new IncompleteDate(this.calendar, this.hourCycle);\n    res.era = this.era;\n    res.year = this.year;\n    res.month = this.month;\n    res.day = this.day;\n    res.hour = this.hour;\n    res.dayPeriod = this.dayPeriod;\n    res.minute = this.minute;\n    res.second = this.second;\n    res.millisecond = this.millisecond;\n    res.offset = this.offset;\n    return res;\n  }\n\n  /** Checks whether all the specified segments have a value. */\n  isComplete(segments: SegmentType[]) {\n    return segments.every(segment => this[segment] != null);\n  }\n\n  /** Checks whether the given date value matches this value for the specified segments. */\n  validate(dt: DateValue, segments: SegmentType[]) {\n    return segments.every(segment => {\n      if ((segment === 'hour' || segment === 'dayPeriod') && 'hour' in dt) {\n        let [dayPeriod, hour] = toHourCycle(dt.hour, this.hourCycle);\n        return this.dayPeriod === dayPeriod && this.hour === hour;\n      }\n      return this[segment] === dt[segment];\n    });\n  }\n\n  /** Checks if the date is empty (i.e. all specified segments are null). */\n  isCleared(segments: SegmentType[]): boolean {\n    return segments.every(segment => this[segment] === null);\n  }\n\n  /** Sets the given field. */\n  set(field: SegmentType, value: number | string, placeholder: DateValue): IncompleteDate {\n    let result = this.copy();\n    result[field] = value;\n    if (field === 'hour' && result.dayPeriod == null && 'hour' in placeholder) {\n      result.dayPeriod = toHourCycle(placeholder.hour, this.hourCycle)[0];\n    }\n    if (field === 'year' && result.era == null) {\n      result.era = placeholder.era;\n    }\n\n    // clear offset when a date/time field changes since it may no longer be valid\n    if (field !== 'second' && field !== 'literal' && field !== 'timeZoneName') {\n      result.offset = null;\n    }\n    return result;\n  }\n\n  /** Sets the given field to null. */\n  clear(field: SegmentType): IncompleteDate {\n    let result = this.copy();\n    // @ts-ignore\n    result[field] = null;\n    if (field === 'year') {\n      result.era = null;\n    }\n\n    // clear offset when a field is cleared since it may no longer be valid\n    result.offset = null;\n    return result;\n  }\n\n  /** Increments or decrements the given field. If it is null, then it is set to the placeholder value. */\n  cycle(field: SegmentType, amount: number, placeholder: DateValue, displaySegments: SegmentType[]): IncompleteDate {\n    let res = this.copy();\n\n    // If field is null, default to placeholder.\n    if (res[field] == null && field !== 'dayPeriod' && field !== 'era') {\n      if (field === 'hour' && 'hour' in placeholder) {\n        let [dayPeriod, hour] = toHourCycle(placeholder.hour, this.hourCycle);\n        res.dayPeriod = dayPeriod;\n        res.hour = hour;\n      } else {\n        res[field] = placeholder[field];\n      }\n      if (field === 'year' && res.era == null) {\n        res.era = placeholder.era;\n      }\n\n      return res;\n    }\n\n    switch (field) {\n      case 'era': {\n        let eras = this.calendar.getEras();\n        let index = eras.indexOf(res.era!);\n        index = cycleValue(index, amount, 0, eras.length - 1);\n        res.era = eras[index];\n        break;\n      }\n      case 'year': {\n        // Use CalendarDate to cycle so that we update the era when going between 1 AD and 1 BC.\n        let date = new CalendarDate(this.calendar, this.era ?? placeholder.era, this.year ?? placeholder.year, this.month ?? 1, this.day ?? 1);\n        date = date.cycle(field, amount, {round: field === 'year'});\n        res.era = date.era;\n        res.year = date.year;\n        break;\n      }\n      case 'month':\n        res.month = cycleValue(res.month ?? 1, amount, 1, this.calendar.getMaximumMonthsInYear());\n        break;\n      case 'day':\n        // Allow incrementing up to the maximum number of days in any month.\n        res.day = cycleValue(res.day ?? 1, amount, 1, this.calendar.getMaximumDaysInMonth());\n        break;\n      case 'hour': {\n        // if date is fully defined or it is just a time field, and we have a time zone, use toValue to get a ZonedDateTime to cycle\n        // so DST fallback is properly handled\n        let hasDateSegements = displaySegments.some(s => ['year', 'month', 'day'].includes(s));\n        if ('timeZone' in placeholder && (!hasDateSegements || (res.year != null && res.month != null && res.day != null))) {\n          let date = this.toValue(placeholder) as ZonedDateTime;\n          date = date.cycle('hour', amount, {hourCycle: this.hourCycle === 'h12' ? 12 : 24, round: false});\n          let [dayPeriod, adjustedHour] = toHourCycle(date.hour, this.hourCycle);\n          res.hour = adjustedHour;\n          res.dayPeriod = dayPeriod;\n          res.offset = date.offset;\n        } else {\n          let hours = res.hour ?? 0;\n          let limits = this.getSegmentLimits('hour')!;\n          res.hour = cycleValue(hours, amount, limits.minValue, limits.maxValue);\n          if (res.dayPeriod == null && 'hour' in placeholder) {\n            res.dayPeriod = toHourCycle(placeholder.hour, this.hourCycle)[0];\n          }\n        }\n        break;\n      }\n      case 'dayPeriod':\n        res.dayPeriod = cycleValue(res.dayPeriod ?? 0, amount, 0, 1);\n        break;\n      case 'minute':\n        res.minute = cycleValue(res.minute ?? 0, amount, 0, 59, true);\n        break;\n      case 'second':\n        res.second = cycleValue(res.second ?? 0, amount, 0, 59, true);\n        break;\n    }\n\n    return res;\n  }\n\n  /** Converts the incomplete date to a full date value, using the provided value for any unset fields. */\n  toValue(value: DateValue): DateValue {\n    if ('hour' in value) {\n      let hour = this.hour;\n      if (hour != null) {\n        hour = fromHourCycle(hour, this.dayPeriod ?? 0, this.hourCycle);\n      } else if (this.hourCycle === 'h12' || this.hourCycle === 'h11') {\n        hour = this.dayPeriod === 1 ? 12 : 0;\n      }\n\n      let res = value.set({\n        era: this.era ?? value.era,\n        year: this.year ?? value.year,\n        month: this.month ?? value.month,\n        day: this.day ?? value.day,\n        hour: hour ?? value.hour,\n        minute: this.minute ?? value.minute,\n        second: this.second ?? value.second,\n        millisecond: this.millisecond ?? value.millisecond\n      });\n\n      if ('offset' in res && this.offset != null && res.offset !== this.offset) {\n        res = res.add({milliseconds: res.offset - this.offset});\n      }\n\n      return res;\n    } else {\n      return value.set({\n        era: this.era ?? value.era,\n        year: this.year ?? value.year,\n        month: this.month ?? value.month,\n        day: this.day ?? value.day\n      });\n    }\n  }\n\n  getSegmentLimits(type: string): {value: number | null, minValue: number, maxValue: number} | undefined {\n    switch (type) {\n      case 'era': {\n        let eras = this.calendar.getEras();\n        return {\n          value: this.era != null ? eras.indexOf(this.era) : eras.length - 1,\n          minValue: 0,\n          maxValue: eras.length - 1\n        };\n      }\n      case 'year':\n        return {\n          value: this.year,\n          minValue: 1,\n          maxValue: 9999\n        };\n      case 'month':\n        return {\n          value: this.month,\n          minValue: 1,\n          maxValue: this.calendar.getMaximumMonthsInYear()\n        };\n      case 'day':\n        return {\n          value: this.day,\n          minValue: 1,\n          maxValue: this.calendar.getMaximumDaysInMonth()\n        };\n      case 'dayPeriod': {\n        return {\n          value: this.dayPeriod,\n          minValue: 0,\n          maxValue: 1\n        };\n      }\n      case 'hour': {\n        let minValue = 0;\n        let maxValue = 23;\n        if (this.hourCycle === 'h12') {\n          minValue = 1;\n          maxValue = 12;\n        } else if (this.hourCycle === 'h11') {\n          minValue = 0;\n          maxValue = 11;\n        }\n\n        return {\n          value: this.hour,\n          minValue,\n          maxValue\n        };\n      }\n      case 'minute':\n        return {\n          value: this.minute,\n          minValue: 0,\n          maxValue: 59\n        };\n      case 'second':\n        return {\n          value: this.second,\n          minValue: 0,\n          maxValue: 59\n        };\n    }\n  }\n}\n\nfunction cycleValue(value: number, amount: number, min: number, max: number, round = false) {\n  if (round) {\n    value += Math.sign(amount);\n\n    if (value < min) {\n      value = max;\n    }\n\n    let div = Math.abs(amount);\n    if (amount > 0) {\n      value = Math.ceil(value / div) * div;\n    } else {\n      value = Math.floor(value / div) * div;\n    }\n\n    if (value > max) {\n      value = min;\n    }\n  } else {\n    value += amount;\n    if (value < min) {\n      value = max - (min - value - 1);\n    } else if (value > max) {\n      value = min + (value - max - 1);\n    }\n  }\n\n  return value;\n}\n\nfunction toHourCycle(hour: number, hourCycle: HourCycle): [number | null, number] {\n  let dayPeriod: number | null = hour >= 12 ? 1 : 0;\n  switch (hourCycle) {\n    case 'h11':\n      // Hours are numbered from 0 to 11. Used in Japan.\n      if (hour >= 12) {\n        hour -= 12;\n      }\n      break;\n    case 'h12':\n      // Hours are numbered from 12 (representing 0) to 11.\n      if (hour === 0) {\n        hour = 12;\n      } else if (hour > 12) {\n        hour -= 12;\n      }\n      break;\n    case 'h23':\n      // 24 hour time, numbered 0 to 23.\n      dayPeriod = null;\n      break;\n    case 'h24':\n      // 24 hour time numbered 24 to 23. Unused but supported by Intl.DateTimeFormat.\n      hour += 1;\n      dayPeriod = null;\n  }\n\n  return [dayPeriod, hour];\n}\n\nfunction fromHourCycle(hour: number, dayPeriod: number, hourCycle: HourCycle): number {\n  switch (hourCycle) {\n    case 'h11':\n      if (dayPeriod === 1) {\n        hour += 12;\n      }\n      break;\n    case 'h12':\n      if (hour === 12) {\n        hour = 0;\n      }\n      if (dayPeriod === 1) {\n        hour += 12;\n      }\n      break;\n    case 'h24':\n      hour -= 1;\n      break;\n  }\n\n  return hour;\n}\n"],"names":[],"version":3,"file":"IncompleteDate.main.js.map"}